version: '3'

vars:
  DOCKER_RUN: docker run --rm -v {{.PWD}}:/workspace supply-chain-tools
  DOCKER_RUN_WITH_SOCKET: docker run --rm -v {{.PWD}}:/workspace -v /var/run/docker.sock:/var/run/docker.sock supply-chain-tools

tasks:
  # =============================================================================
  # Public Tasks - Student-facing interface
  # =============================================================================
  
  build-tools:
    desc: "ğŸ”§ Build supply-chain-tools Docker image"
    cmds:
      - docker build -t supply-chain-tools tools/

  build:
    desc: "ğŸ”¨ Build application in Docker"
    cmds:
      - "{{.DOCKER_RUN}} task _build"
  
  test:
    desc: "ğŸ§ª Run security tests in Docker"
    cmds:
      - "{{.DOCKER_RUN}} task _test"

  pipeline:
    desc: "ğŸš€ Run complete pipeline in Docker"
    cmds:
      - "{{.DOCKER_RUN}} task _pipeline"

  scan-all:
    desc: "ğŸ” Run all security scans in Docker"
    cmds:
      - "{{.DOCKER_RUN}} task _scan-all"

  scan-source:
    desc: "ğŸ“ Scan source code in Docker"
    cmds:
      - "{{.DOCKER_RUN}} task _scan-source"

  scan-deps:
    desc: "ğŸ“¦ Scan dependencies in Docker"
    cmds:
      - "{{.DOCKER_RUN}} task _scan-deps"

  scan-dockerfile:
    desc: "ğŸ³ Scan Dockerfile in Docker"
    cmds:
      - "{{.DOCKER_RUN}} task _scan-dockerfile -- severity MEDIUM,HIGH,CRITICAL"

  scan-iac:
    desc: "ğŸ—ï¸ Scan IaC in Docker"
    cmds:
      - "{{.DOCKER_RUN}} task _scan-iac"

  scan-manifests:
    desc: "â˜¸ï¸ Scan K8s manifests in Docker"
    cmds:
      - "{{.DOCKER_RUN}} task _scan-manifests"

  generate-sbom:
    desc: "ğŸ“‹ Generate SBOM in Docker"
    cmds:
      - "{{.DOCKER_RUN}} task _generate-sbom"

  sign-image:
    desc: "ğŸ” Sign container image with ephemeral keys"
    cmds:
      - "{{.DOCKER_RUN_WITH_SOCKET}} task _sign-image"

  build-image:
    desc: "ğŸ—ï¸ Build container image"
    cmds:
      - echo "Building container image..."
      - docker build -f src/docker/Dockerfile -t supply-chain-app:latest src/
      - echo "Container image built successfully"

  build-image-with-attestation:
    desc: "ğŸ—ï¸ Build container image with provenance"
    cmds:
      - export BUILDX_METADATA_PROVENANCE=max BUILDX_GIT_INFO=1 BUILDX_GIT_LABELS=1 BUILDER_ID="$(whoami)@$(hostname)"
      - echo "Building container image with attestation artifacts..."
      - docker buildx build --provenance=mode=max,builder-id="azureuser@vm-lab-nestor" --sbom=true -o type=local,dest=./out -f src/docker/Dockerfile src
      - echo "Container with attestation built successfully"

  scan-image:
    desc: "ğŸ” Scan built container image for vulnerabilities"
    cmds:
      - "{{.DOCKER_RUN_WITH_SOCKET}} task _scan-image"

  exec:
    desc: "ğŸ”§ Execute command inside supply-chain-tools container (e.g., task exec -- cosign sign --yes $IMAGE)"
    cmds:
      - "{{.DOCKER_RUN_WITH_SOCKET}} {{.CLI_ARGS}}"

  verify-image:
    desc: "ğŸ” Verify container image signature with public key"
    cmds:
      - "{{.DOCKER_RUN_WITH_SOCKET}} task _verify-image"

  validate:provenance:
    desc: "âœ… Validate SLSA provenance attestation"
    cmds:
      - "{{.DOCKER_RUN}} ./scripts/validate-provenance.sh"

  validate:sbom:
    desc: "âœ… Validate SBOM attestation"
    cmds:
      - "{{.DOCKER_RUN}} ./scripts/validate-sbom.sh"

  validate:vuln-source:
    desc: "âœ… Validate source vulnerability attestation"
    cmds:
      - "{{.DOCKER_RUN}} ./scripts/validate-vuln.sh source"

  validate:vuln-iac:
    desc: "âœ… Validate IaC vulnerability attestation"
    cmds:
      - "{{.DOCKER_RUN}} ./scripts/validate-vuln.sh iac"

  validate:vuln-image:
    desc: "âœ… Validate image vulnerability attestation"
    cmds:
      - "{{.DOCKER_RUN}} ./scripts/validate-vuln.sh image"

  validate:all-attestations:
    desc: "âœ… Validate all Phase 2 attestations"
    cmds:
      - task validate:provenance
      - task validate:sbom
      - task validate:vuln-source
      - task validate:vuln-iac
      - task validate:vuln-image
      - echo "ğŸ‰ All attestations validated successfully!"

  validate:phase3:
    desc: "âœ… Validate Phase 3 keyless signing completion"
    cmds:
      - |
        echo "ğŸ” Validating Phase 3 completion..."
        
        # Check environment variables
        if [ -z "$DIGEST" ]; then
          echo "âŒ DIGEST variable not set"
          echo "   Set with: export DIGEST=sha256:..."
          exit 1
        fi
        echo "âœ… DIGEST variable set"
        
        if [ -z "$IMAGE" ]; then
          echo "âŒ IMAGE variable not set"
          echo "   Set with: export IMAGE=ttl.sh/supply-chain-app-\$(whoami)@\$DIGEST"
          exit 1
        fi
        echo "âœ… IMAGE variable set: $IMAGE"
        
        # Verify signature and attestations in one call
        echo ""
        echo "ğŸ” Verifying signature and attestations..."
        VERIFY_OUTPUT=$(cosign verify --experimental-oci11 --certificate-identity-regexp=".*" --certificate-oidc-issuer-regexp=".*" $IMAGE 2>&1)
        
        if ! echo "$VERIFY_OUTPUT" | grep -q "Verification for"; then
          echo "âŒ Verification failed"
          echo "   Did you run: cosign sign --yes \$IMAGE"
          exit 1
        fi
        
        # Extract JSON and count types
        JSON_OUTPUT=$(echo "$VERIFY_OUTPUT" | grep '^\[')
        
        # Check for image signature (type: cosign/sign/v1)
        SIGNATURE_COUNT=$(echo "$JSON_OUTPUT" | jq '[.[] | select(.critical.type == "https://sigstore.dev/cosign/sign/v1")] | length' 2>/dev/null || echo "0")
        
        if [ "$SIGNATURE_COUNT" -ge 1 ]; then
          echo "âœ… Image signature verified"
        else
          echo "âŒ Image signature not found"
          echo "   Did you run: cosign sign --yes \$IMAGE"
          exit 1
        fi
        
        # Count attestations (exclude cosign/sign/v1)
        ATTESTATION_COUNT=$(echo "$JSON_OUTPUT" | jq '[.[] | select(.critical.type != "https://sigstore.dev/cosign/sign/v1")] | length' 2>/dev/null || echo "0")
        
        echo "âœ… Attestations verified"
        echo "   Found $ATTESTATION_COUNT signed attestations"
        
        if [ "$ATTESTATION_COUNT" -ge 5 ]; then
          echo "âœ… At least 5 attestations present (provenance, SBOM, 3x vuln)"
        else
          echo "âš ï¸  Expected at least 5 attestations, found $ATTESTATION_COUNT"
          echo "   Make sure you signed: provenance, SBOM, vuln-source, vuln-iac, vuln-image"
        fi
        
        # Check Rekor entries
        echo ""
        echo "ğŸ“ Checking Rekor transparency log..."
        HASH=$(echo $DIGEST | cut -d: -f2)
        ENTRY_COUNT=$(rekor-cli search --sha $HASH 2>/dev/null | grep -c "^[a-f0-9]" || echo "0")
        
        echo "   Found $ENTRY_COUNT Rekor entries"
        
        if [ "$ENTRY_COUNT" -ge 6 ]; then
          echo "âœ… Complete transparency log (expected: 6)"
          echo "   1 image signature + 5 attestations = 6 entries"
        elif [ "$ENTRY_COUNT" -eq 5 ]; then
          echo "âš ï¸  Found 5 entries (expected: 6)"
          echo "   Possible cause: Missing 'cosign sign' step (Exercise 3.2)"
          echo "   Or missing one attestation (Exercise 3.4-3.5)"
        else
          echo "âŒ Incomplete transparency log (expected: 6, found: $ENTRY_COUNT)"
          echo "   Expected: 1 image signature + 5 attestations"
          exit 1
        fi
        
        echo ""
        echo "ğŸ‰ Phase 3 validation complete!"
        echo "âœ… Image signed with keyless signing"
        echo "âœ… All attestations signed and attached"
        echo "âœ… Entries logged in Rekor transparency log"

  pipeline-skip-security:
    desc: "âš ï¸ Run build pipeline without security checks (testing only)"
    cmds:
      - echo "âš ï¸ SKIPPING SECURITY CHECKS - FOR TESTING ONLY"
      - task build
      - task build-image
      - task generate-sbom
      - task sign-image
      - echo "ğŸ‰ Build pipeline complete (security checks skipped)"
      - echo "âœ… Application built"
      - echo "âœ… Container image built"
      - echo "âœ… SBOM generated"
      - echo "âœ… Container image signed"
      - echo "âš ï¸ Run 'task pipeline' to include security checks"

  # =============================================================================
  # Private Tasks - Internal implementation (prefixed with _)
  # Note: No 'desc' field = hidden from 'task --list' but still callable
  # =============================================================================

  _build:
    # Internal: Build the application
    cmds:
      - echo "ğŸ”¨ Building Application..."
      - cd src/app && uv sync
      - echo "âœ… Build complete"

  _test:
    # Internal: Run security tests
    cmds:
      - echo "ğŸ§ª Running Security Tests..."
      - cd src/app && uv run pytest ../tests/ -v

  _pipeline:
    # Internal: Run complete secure development pipeline
    cmds:
      - task _build
      - task _test
      - task _scan-all
      - task _generate-sbom
      - task _sign-image
      - echo "ğŸ‰ Complete pipeline succeeded!"
      - echo "âœ… Application built and tested"
      - echo "âœ… Security scans passed"
      - echo "âœ… SBOM generated"
      - echo "âœ… Container image signed"

  _scan-all:
    # Internal: Run all security scans
    cmds:
      - task _scan-source
      - task _scan-deps
      - task _scan-dockerfile
      - task _scan-iac
      - task _scan-manifests
      - echo "ğŸ“Š All scans complete"

  _scan-source:
    # Internal: Scan source code with Bandit
    cmds:
      - echo "ğŸ“ Scanning source code..."
      - echo "â„¹ï¸ Using Bandit to scan for hardcoded secrets, SQL injection, and other code security issues"
      - bandit -r src/app/main.py --exclude src/app/.venv

  _scan-deps:
    # Internal: Scan dependencies with Trivy
    cmds:
      - echo "ğŸ“¦ Scanning dependencies..."
      - echo "â„¹ï¸ Using Trivy to scan for vulnerable dependencies"
      - trivy fs --scanners vuln --severity HIGH,CRITICAL src/app/

  _scan-dockerfile:
    # Internal: Scan Dockerfile configuration with Trivy
    cmds:
      - echo "ğŸ³ Scanning Dockerfile..."
      - echo "â„¹ï¸ Using Trivy to scan for Dockerfile misconfigurations"
      - trivy config src/docker/Dockerfile

  _scan-iac:
    # Internal: Scan Infrastructure as Code with Checkov
    cmds:
      - echo "ğŸ—ï¸ Scanning IaC..."
      - checkov -f src/iac/main.tf --skip-check CKV2_AWS_5

  _scan-manifests:
    # Internal: Scan Kubernetes manifests with Trivy
    cmds:
      - echo "â˜¸ï¸ Scanning manifests..."
      - trivy config src/k8s/ --severity HIGH,CRITICAL

  _scan-image:
    # Internal: Scan container image with Trivy
    cmds:
      - echo "ğŸ” Scanning container image..."
      - echo "â„¹ï¸ Using Trivy to scan for vulnerabilities in built image"
      - trivy image supply-chain-app:latest --scanners vuln --severity HIGH,CRITICAL

  _generate-sbom:
    # Internal: Generate Software Bill of Materials with Syft
    cmds:
      - echo "ğŸ“‹ Generating SBOM..."
      - syft src/ -o spdx-json > sbom.json
      - echo "âœ… SBOM saved to sbom.json"

  _sign-image:
    # Internal: Sign container image with ephemeral Cosign keys
    # TODO: Replace ephemeral keys with keyless signing (Fulcio + Rekor + OIDC)
    # See plan.md Task 4 Phase 3 for keyless implementation
    cmds:
      - echo "ğŸ” Signing container image..."
      - echo "ğŸ”‘ Generating ephemeral signing keys..."
      - echo "ğŸ“¦ Tagging image for ttl.sh temporary registry..."
      - |
        # Generate ephemeral cosign key pair (inside container, private key stays there)
        echo "y" | COSIGN_PASSWORD="" cosign generate-key-pair
        
        # Copy public key to output directory for verification
        cp cosign.pub output/signing-key.pub
        echo "ğŸ”‘ Public key saved to output/signing-key.pub"
        
        # Generate unique image name for ttl.sh (24h expiry)
        IMAGE_ID=$(date +%s)-$(head -c 8 /dev/urandom | base64 | tr -dc 'a-z0-9' | head -c 8)
        TTL_IMAGE="ttl.sh/supply-chain-${IMAGE_ID}:24h"
        echo "ğŸ·ï¸ Using temporary image: ${TTL_IMAGE}"
        
        # Tag and push to ttl.sh
        docker tag supply-chain-app:latest ${TTL_IMAGE}
        echo "ğŸ“¤ Pushing to temporary registry..."
        docker push ${TTL_IMAGE}
        
        # Sign the image using ephemeral key
        echo "âœï¸ Signing image with ephemeral cosign key..."
        COSIGN_PASSWORD="" cosign sign --key cosign.key --yes ${TTL_IMAGE}
        
        # Store the image name for verification (in output directory)
        echo ${TTL_IMAGE} > output/.signed-image
        echo "âœ… Container image signed successfully!"
        echo "ğŸ“ Artifacts saved to output/ directory:"
        echo "   - output/.signed-image (image reference)"
        echo "   - output/signing-key.pub (public key for verification)"
        echo "ğŸ” You can verify with: task verify-image"

  _verify-image:
    # Internal: Verify container image signature with ephemeral public key
    cmds:
      - echo "ğŸ” Verifying container image signature..."
      - |
        # Check if we have a signed image to verify
        if [ ! -f output/.signed-image ]; then
          echo "âŒ No signed image found. Run 'task sign-image' first."
          exit 1
        fi
        
        # Check if we have the public key for verification
        if [ ! -f output/signing-key.pub ]; then
          echo "âŒ No public key found. Run 'task sign-image' first."
          exit 1
        fi
        
        SIGNED_IMAGE=$(cat output/.signed-image)
        echo "ğŸ¯ Verifying image: ${SIGNED_IMAGE}"
        echo "ğŸ”‘ Using public key: output/signing-key.pub"
        
        # Verify the signature using the ephemeral public key
        echo "ğŸ” Verifying signature with ephemeral public key..."
        if cosign verify --key output/signing-key.pub ${SIGNED_IMAGE}; then
          echo "âœ… Signature verification successful!"
          echo "ğŸ”’ Image integrity confirmed"
          echo "ğŸ“‹ Signature details shown above"
        else
          echo "âŒ Signature verification failed!"
          exit 1
        fi
